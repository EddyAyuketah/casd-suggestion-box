import { useState, useEffect, useCallback } from 'react';
import { DEFAULT_CONFIG } from '../config/defaults';
import * as calc from '../utils/calculations';

// Fetch directly from NAZ - updates every 15 minutes automatically
const LINEVIEW_URL = 'https://azshweb.intel.com/azAnalysis$/1274_MAODATA/MfgEng/COS_DB/LineView.txt';
const CEID_URL = 'https://azshweb.intel.com/azAnalysis$/1274_MAODATA/MfgEng/COS_DB/CEID.txt';

function parseTSV(text) {
  const lines = text.trim().split('\n');
  const headers = lines[0].split('\t');
  
  return lines.slice(1).map(line => {
    const values = line.split('\t');
    const obj = {};
    headers.forEach((header, i) => {
      obj[header] = values[i];
    });
    return obj;
  });
}

export function useDashboard() {
  const [config, setConfig] = useState(() => {
    const saved = localStorage.getItem('dashboardConfig');
    return saved ? JSON.parse(saved) : DEFAULT_CONFIG;
  });

  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [autoRefresh, setAutoRefresh] = useState(true);
  const [lastUpdate, setLastUpdate] = useState(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('Fetching latest data from NAZ...');
      
      // Fetch data files directly - they update every 15 minutes
      const [lineviewResponse, ceidResponse] = await Promise.all([
        fetch(LINEVIEW_URL + '?t=' + Date.now()), // Cache buster
        fetch(CEID_URL + '?t=' + Date.now())
      ]);
      
      if (!lineviewResponse.ok) {
        throw new Error(`LineView fetch failed: ${lineviewResponse.status}`);
      }
      if (!ceidResponse.ok) {
        throw new Error(`CEID fetch failed: ${ceidResponse.status}`);
      }
      
      const lineviewText = await lineviewResponse.text();
      const ceidText = await ceidResponse.text();
      
      const lineview = parseTSV(lineviewText);
      const ceid = parseTSV(ceidText);
      
      console.log(`âœ… Loaded ${lineview.length} lineview records and ${ceid.length} CEID records`);
      
      const now = new Date();
      
      // Find finish operation row to extract shipment data
      const finishOp = lineview.find(row => calc.safeNum(row.OPERATION) === config.be_lsb_operation);
      if (!finishOp) throw new Error('Finish operation not found in LineView');
      
      // Calculate quarter ships from weekly averages (approximation)
      const quarterStartDate = new Date(config.quarter_start || '2025-09-06T18:00:00');
      const daysIntoQuarter = Math.max(0, (now - quarterStartDate) / (1000 * 60 * 60 * 24));
      const weeksIntoQuarter = daysIntoQuarter / 7;
      
      const currentWeekOuts = calc.safeNum(finishOp.CW_OUTS_PROD, 0);
      const lastWeekOuts = calc.safeNum(finishOp.PW_OUTS_PROD, 0);
      const avgWeeklyRate = (currentWeekOuts + lastWeekOuts) / 2;
      
      const quarterShips = Math.round(avgWeeklyRate * weeksIntoQuarter);
      
      console.log('ðŸ“Š Shipment data (quarter approximated from weekly avg):');
      console.log('  Current week:', currentWeekOuts);
      console.log('  Last week:', lastWeekOuts);
      console.log('  Avg weekly rate:', avgWeeklyRate.toFixed(0));
      console.log('  Weeks into quarter:', weeksIntoQuarter.toFixed(1));
      console.log('  â†’ Quarter total:', quarterShips);
      
      // Extract shipment data from LineView columns
      const shipmentData = {
        current_shift_ships: calc.safeNum(finishOp.CS_OUTS, 0),
        quarter_ships: quarterShips,
        last_week_ships: lastWeekOuts,
        last_24h_ships: calc.safeNum(finishOp.PS_OUTS, 0),
        current_week_outs: currentWeekOuts
      };
      
      const beLsbFls = calc.safeNum(finishOp.FULL_LOOP_SEQ);
      
      // Perform all calculations
      const shiftInfo = calc.getCurrentShiftInfo();
      const targetPerShift = config.outs_goal / calc.SHIFTS_PER_WEEK;
      const shiftPaceRate = shiftInfo.hoursIntoShift > 0 
        ? shipmentData.current_shift_ships / shiftInfo.hoursIntoShift : 0;
      const projectedShiftEnd = shipmentData.current_shift_ships + 
        (shiftPaceRate * shiftInfo.hoursRemaining);
      
      const quarterRemaining = Math.max(0, config.quarter_goal - shipmentData.quarter_ships);
      
      const { pullPoint, opsWithPP } = calc.calculateQuarterlyPullPoint(lineview, quarterRemaining, beLsbFls);
      const ppFullLoopSeq = calc.safeNum(pullPoint.FULL_LOOP_SEQ);
      const ppSegmentDay = calc.safeNum(pullPoint.SEGMENT_DAY, 0);
      
      const bumpInventory = calc.calculateBumpInventory(opsWithPP, quarterRemaining);
      const daysInfo = calc.calculateDaysRemaining(config, pullPoint, now);
      const pullPoint24h = calc.calculate24HourPullPoint(lineview, pullPoint, finishOp, config, beLsbFls);
      const weeklyInfo = calc.calculateWeeklyTargets(config, finishOp, shipmentData, now);
      
      // Build response object
      const dashboardData = {
        timestamp: now.toISOString(),
        shift: {
          name: shiftInfo.shiftName,
          start: shiftInfo.shiftStart.toISOString(),
          hours_into: Math.round(shiftInfo.hoursIntoShift * 10) / 10,
          hours_remaining: Math.round(shiftInfo.hoursRemaining * 10) / 10,
          shipped: Math.round(shipmentData.current_shift_ships),
          target: Math.round(targetPerShift),
          pace_rate: Math.round(shiftPaceRate * 10) / 10,
          projected_end: Math.round(projectedShiftEnd),
          status: projectedShiftEnd >= targetPerShift ? 'ON PACE' : 'BEHIND PACE',
          ct_progress_needed: config.catchup_ct_target / 2
        },
        quarterly: {
          goal: config.quarter_goal,
          shipped: Math.round(shipmentData.quarter_ships),
          remaining: Math.round(quarterRemaining),
          percent_complete: Math.round((shipmentData.quarter_ships / config.quarter_goal) * 1000) / 10
        },
        weekly: {
          last_week_ships: Math.round(shipmentData.last_week_ships),
          weekly_goal: config.outs_goal,
          variance: Math.round(shipmentData.last_week_ships - config.outs_goal),
          this_week_required: Math.round(weeklyInfo.thisWeekRequired),
          this_week_shipped: Math.round(weeklyInfo.currentWeekOuts),
          remaining_this_week: Math.round(weeklyInfo.outsRemainingThisWeek),
          days_left: Math.round(weeklyInfo.daysLeft * 100) / 100,
          shifts_left: weeklyInfo.shiftsLeft,
          need_per_day: Math.round(weeklyInfo.needPerDay * 10) / 10,
          need_per_shift: Math.round(weeklyInfo.needPerShift * 10) / 10,
          shortfall: Math.round(weeklyInfo.totalShortfall)
        },
        daily: {
          last_24h_ships: Math.round(shipmentData.last_24h_ships),
          target: Math.round(targetPerShift * 2),
          variance: Math.round(shipmentData.last_24h_ships - (targetPerShift * 2)),
          status: shipmentData.last_24h_ships >= (targetPerShift * 2) ? 'HIT' : 'MISS'
        },
        pull_point: {
          current_sd: ppSegmentDay,
          current_ceid: pullPoint.CEID || 'N/A',
          current_operation: pullPoint.OPERATION || 'N/A',
          current_desc: pullPoint.OPER_SHORT_DESC || 'N/A',
          current_fls: ppFullLoopSeq,
          bump_inventory: Math.round(bumpInventory),
          segment_days_remaining: daysInfo.segmentDays,
          calendar_days_remaining: daysInfo.calendarDays,
          commit_ahead_behind: daysInfo.commitAheadBehind,
          commit_status: daysInfo.commitStatus
        },
        pull_point_24h: {
          target_ct_hours: config.catchup_ct_target,
          operations_count: pullPoint24h.ops24h.length,
          start_sd: pullPoint24h.first24hOp ? calc.safeNum(pullPoint24h.first24hOp.SEGMENT_DAY, 0) : ppSegmentDay,
          start_ceid: pullPoint24h.first24hOp ? (pullPoint24h.first24hOp.CEID || 'N/A') : 'N/A',
          end_sd: pullPoint24h.last24hOp ? calc.safeNum(pullPoint24h.last24hOp.SEGMENT_DAY, 0) : ppSegmentDay,
          end_ceid: pullPoint24h.last24hOp ? (pullPoint24h.last24hOp.CEID || 'N/A') : 'N/A',
          end_desc: pullPoint24h.last24hOp ? (pullPoint24h.last24hOp.OPER_SHORT_DESC || 'N/A') : 'N/A',
          ps_outs: Math.round(pullPoint24h.psOuts),
          pps_outs: Math.round(pullPoint24h.ppsOuts),
          inventory_reduction: Math.round(pullPoint24h.psOuts + pullPoint24h.ppsOuts)
        },
        limiters: [],
        config
      };
      
      setData(dashboardData);
      setLastUpdate(new Date());
      
    } catch (err) {
      console.error('Dashboard fetch error:', err);
      setError(err.message || 'Failed to load data');
    } finally {
      setLoading(false);
    }
  }, [config]);

  const fetchHistory = useCallback(async (days = 14) => {
    console.log('History feature not available');
    return null;
  }, []);

  const updateConfig = useCallback((newConfig) => {
    setConfig(newConfig);
    localStorage.setItem('dashboardConfig', JSON.stringify(newConfig));
  }, []);

  const resetConfig = useCallback(() => {
    setConfig(DEFAULT_CONFIG);
    localStorage.removeItem('dashboardConfig');
  }, []);

  // Auto-refresh every 5 minutes (data updates every 15 min)
  useEffect(() => {
    let interval;
    if (autoRefresh) {
      interval = setInterval(() => fetchData(), 5 * 60 * 1000);
    }
    return () => {
      if (interval) clearInterval(interval);
    };
  }, [autoRefresh, fetchData]);

  // Initial fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return {
    data,
    loading,
    error,
    config,
    lastUpdate,
    historyData: null,
    historyLoading: false,
    updateConfig,
    resetConfig,
    refreshData: fetchData,
    fetchHistory,
    autoRefresh,
    setAutoRefresh
  };
}
