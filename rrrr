This is my server.js code

const express = require('express');
const fs = require('fs');
const path = require('path');
const cors = require('cors');
const { parse } = require('csv-parse/sync');
const { spawn } = require('child_process');

const app = express();
const PORT = 5000;

app.use(cors());
app.use(express.json());

// File paths
const LINEVIEW_PATH = process.env.LINEVIEW_PATH || 
  '\\\\azshfs.intel.com\\azanalysistop\\AZAnalysis\\1274_MAODATA\\AZFSM_Production\\COS_DB\\Combined\\LineView.TXT';

const CEID_PATH = process.env.CEID_PATH || 
  '\\\\azshfs.intel.com\\azanalysistop\\AZAnalysis\\1274_MAODATA\\AZFSM_Production\\COS_DB\\Combined\\CEID.TXT';

const LOCAL_LINEVIEW_PATH = path.join(__dirname, 'data', 'LineView.TXT');
const LOCAL_CEID_PATH = path.join(__dirname, 'data', 'CEID.TXT');

// Constants matching Python script EXACTLY
const SHIFTS_PER_WEEK = 14;
const SHIFT_START_HOURS = [6, 18];
const HOURS_PER_SHIFT = 12;
const LIMITER_HAO_MULTIPLIER = 2.5;
const LIMITER_INV_MULTIPLIER = 2.0;
const LIMITER_INV_MIN_THRESHOLD = 300;
const LIMITER_INV_STARVATION_THRESHOLD = 0.75;
const LIMITER_CT_MIN_THRESHOLD = 1.0;
const LIMITER_WSPW_GAP = 1000;
const LAYER_COUNT_THRESHOLD = 0.30;
const EXCLUDED_OPERATIONS = [204];

/**
 * Read TSV file from network or local path
 */
function readTSVFile(networkPath, localPath) {
  return new Promise((resolve, reject) => {
    fs.readFile(networkPath, 'utf8', (err, data) => {
      if (err) {
        console.log(`Network path unavailable, trying local: ${localPath}`);
        fs.readFile(localPath, 'utf8', (err2, data2) => {
          if (err2) {
            reject(new Error(`Failed to read file from both paths`));
          } else {
            resolve(data2);
          }
        });
      } else {
        resolve(data);
      }
    });
  });
}

/**
 * Parse TSV data
 */
function parseTSV(data) {
  try {
    const records = parse(data, {
      columns: true,
      skip_empty_lines: true,
      delimiter: '\t',
      relax_quotes: true,
      trim: true
    });
    return records;
  } catch (error) {
    throw new Error(`TSV parsing error: ${error.message}`);
  }
}

/**
 * Safe number conversion (matches Python safe_num)
 */
function safeNum(value, defaultValue = null) {
  const num = parseFloat(value);
  return isNaN(num) ? defaultValue : num;
}

/**
 * Get current shift info (matches Python get_current_shift_info)
 */
function getCurrentShiftInfo() {
  const now = new Date();
  const hour = now.getHours();
  
  let shiftStart, shiftName;
  
  if (hour >= SHIFT_START_HOURS[0] && hour < SHIFT_START_HOURS[1]) {
    // Day shift (6am - 6pm)
    shiftStart = new Date(now);
    shiftStart.setHours(SHIFT_START_HOURS[0], 0, 0, 0);
    shiftName = 'Day';
  } else {
    // Night shift (6pm - 6am next day)
    if (hour >= SHIFT_START_HOURS[1]) {
      shiftStart = new Date(now);
      shiftStart.setHours(SHIFT_START_HOURS[1], 0, 0, 0);
    } else {
      // After midnight, shift started yesterday at 6pm
      shiftStart = new Date(now);
      shiftStart.setDate(shiftStart.getDate() - 1);
      shiftStart.setHours(SHIFT_START_HOURS[1], 0, 0, 0);
    }
    shiftName = 'Night';
  }
  
  const hoursIntoShift = (now - shiftStart) / (1000 * 60 * 60);
  
  return {
    shiftStart,
    shiftName,
    hoursIntoShift,
    hoursRemaining: HOURS_PER_SHIFT - hoursIntoShift
  };
}

/**
 * Calculate quarterly pull point (matches Python exactly)
 */
function calculateQuarterlyPullPoint(lineview, quarterRemaining, beLsbFls) {
  // Filter operations up to finish, excluding operation 204
  const relevantOps = lineview
    .filter(row => {
      const fls = safeNum(row.FULL_LOOP_SEQ);
      const op = safeNum(row.OPERATION);
      return fls !== null && fls <= beLsbFls && op !== 204;
    })
    .sort((a, b) => safeNum(a.FULL_LOOP_SEQ) - safeNum(b.FULL_LOOP_SEQ));
  
  // Calculate reverse cumulative inventory (Python: df_q["PP_INV"] = df_q["INV_PROD"].iloc[::-1].cumsum()[::-1])
  let cumulativeInv = 0;
  const opsWithPP = [];
  
  // Go backwards through array
  for (let i = relevantOps.length - 1; i >= 0; i--) {
    const row = relevantOps[i];
    cumulativeInv += safeNum(row.INV_PROD, 0);
    
    opsWithPP.unshift({
      ...row,
      PP_INV: cumulativeInv,
      PP_W: quarterRemaining > 0 ? Math.floor(cumulativeInv / quarterRemaining) : 0
    });
  }
  
  // Find pull point: last operation where PP_W == 1 (Python: df_q.query("PP_W == 1").tail(1))
  let pullPoint = null;
  for (let i = opsWithPP.length - 1; i >= 0; i--) {
    if (opsWithPP[i].PP_W >= 1) {
      pullPoint = opsWithPP[i];
      break;
    }
  }
  
  if (!pullPoint) {
    pullPoint = opsWithPP[opsWithPP.length - 1]; // Last operation
  }
  
  return pullPoint;
}

/**
 * Check if inventory starved (matches Python is_inventory_starved)
 */
function isInventoryStarved(invProd, invGoal) {
  if (invProd === null || invGoal === null || invGoal <= 0) {
    return false;
  }
  return invProd < (invGoal * LIMITER_INV_STARVATION_THRESHOLD);
}

/**
 * Calculate severity score (matches Python calculate_severity_score)
 */
function calculateSeverityScore(reasonsDict, ctGoal) {
  let score = 0;
  const ctWeight = Math.min(ctGoal / 5.0, 2.0); // Max 2x multiplier for long ops
  
  for (const [reasonType, reasonText] of Object.entries(reasonsDict)) {
    if (reasonType === 'HAO') {
      score += 40 * ctWeight;
    } else if (reasonType === 'INV') {
      score += 30 * ctWeight;
    } else if (reasonType === 'WSPW') {
      score += 25 * ctWeight;
    } else if (reasonType === 'CS_PACE') {
      score += 35 * ctWeight;
    }
  }
  
  return Math.min(score, 100); // Cap at 100
}

/**
 * Calculate limiters (matches Python logic)
 */
function calculateLimiters(lineview, ceid, ppFullLoopSeq, beLsbFls, config) {
  const { lookahead_hours, outs_goal } = config;
  
  // Get operations after current PP
  const nextOps = lineview
    .filter(row => {
      const fls = safeNum(row.FULL_LOOP_SEQ);
      const op = safeNum(row.OPERATION);
      const layerCount = safeNum(row.LAYER_COUNT, 1);
      return fls > ppFullLoopSeq && fls <= beLsbFls && 
             op !== 204 && layerCount >= LAYER_COUNT_THRESHOLD;
    })
    .sort((a, b) => safeNum(a.FULL_LOOP_SEQ) - safeNum(b.FULL_LOOP_SEQ));
  
  // Calculate cumulative CT
  let cumulativeCT = 0;
  const lookaheadOps = [];
  
  for (const row of nextOps) {
    const ctGoal = safeNum(row.CT_GOAL, 0);
    cumulativeCT += ctGoal;
    
    if (cumulativeCT <= lookahead_hours && ctGoal >= LIMITER_CT_MIN_THRESHOLD) {
      lookaheadOps.push({
        ...row,
        CUMULATIVE_CT: cumulativeCT
      });
    }
  }
  
  const limiters = [];
  
  for (const row of lookaheadOps) {
    const reasonsDict = {};
    const reasonsList = [];
    
    const avgHao = safeNum(row.AVG_HAO);
    const ctGoal = safeNum(row.CT_GOAL, 0);
    const invProd = safeNum(row.INV_PROD, 0);
    const invGoal = safeNum(row.INV_GOAL, 1);
    const ceidVal = row.CEID;
    
    const isStarved = isInventoryStarved(invProd, invGoal);
    
    // CRITERIA 1: HAO violation (matches Python)
    if (avgHao !== null && ctGoal > 0 && avgHao >= (ctGoal * LIMITER_HAO_MULTIPLIER)) {
      const multiplier = (avgHao / ctGoal).toFixed(1);
      reasonsDict['HAO'] = `AVG_HAO ${multiplier}√óCT (${avgHao.toFixed(1)}h vs ${ctGoal.toFixed(1)}h)`;
      reasonsList.push(reasonsDict['HAO']);
    }
    
    // CRITERIA 2: Inventory buildup (matches Python)
    if (invGoal > 0 && invProd >= (invGoal * LIMITER_INV_MULTIPLIER) && 
        invProd >= LIMITER_INV_MIN_THRESHOLD) {
      const multiplier = (invProd / invGoal).toFixed(1);
      reasonsDict['INV'] = `INV ${multiplier}√óGOAL (${invProd.toFixed(0)} vs ${invGoal.toFixed(0)} wfrs)`;
      reasonsList.push(reasonsDict['INV']);
    }
    
    // CRITERIA 3: CEID-based checks (only if not starved)
    if (!isStarved && ceidVal && ceid.length > 0) {
      const ceidRow = ceid.find(c => c.CEID === ceidVal);
      
      if (ceidRow) {
        const wspw = safeNum(ceidRow.CS_WSPW_PACE);
        const wse = safeNum(ceidRow.WSE_GOAL);
        const csPace = safeNum(ceidRow.CS_PACE);
        const roads = safeNum(ceidRow.ROADS_CAPACITY);
        
        // WSPW check (matches Python)
        if (wspw !== null && wse !== null && wse > 0) {
          const paceGap = wse - wspw;
          if (paceGap >= LIMITER_WSPW_GAP) {
            const pctBelow = ((paceGap / wse) * 100).toFixed(0);
            reasonsDict['WSPW'] = `WSPW ${pctBelow}% below goal (${paceGap.toFixed(0)} wfrs)`;
            reasonsList.push(reasonsDict['WSPW']);
          }
        }
        
        // CS_PACE check (matches Python)
        if (roads !== null && csPace !== null && roads >= outs_goal) {
          const weeklyPace = csPace * SHIFTS_PER_WEEK;
          if (weeklyPace < outs_goal) {
            const pctBelow = (((outs_goal - weeklyPace) / outs_goal) * 100).toFixed(0);
            reasonsDict['CS_PACE'] = `CS_PACE ${pctBelow}% below target (${weeklyPace.toFixed(0)} vs ${outs_goal})`;
            reasonsList.push(reasonsDict['CS_PACE']);
          }
        }
      }
    }
    
    if (reasonsList.length > 0) {
      const severity = calculateSeverityScore(reasonsDict, ctGoal);
      
      limiters.push({
        ceid: ceidVal || 'N/A',
        operation: row.OPERATION || 'N/A',
        description: row.OPER_SHORT_DESC || 'N/A',
        segment_day: safeNum(row.SEGMENT_DAY, 0),
        ct_goal: ctGoal,
        avg_hao: avgHao,
        inv_prod: invProd,
        inv_goal: invGoal,
        severity,
        reasons: reasonsList.join(' | ')
      });
    }
  }
  
  // Sort by severity and return top 10 (matches Python)
  return limiters
    .sort((a, b) => b.severity - a.severity)
    .slice(0, 10);
}

/**
 * Call Python script for database queries
 */
function callPythonScript(scriptName, args) {
  return new Promise((resolve, reject) => {
    const pythonPath = path.join(__dirname, 'python', scriptName);
    const python = spawn('python', [pythonPath, ...args]);
    
    let dataString = '';
    let errorString = '';
    
    python.stdout.on('data', (data) => {
      dataString += data.toString();
    });
    
    python.stderr.on('data', (data) => {
      errorString += data.toString();
    });
    
    python.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`Python script failed: ${errorString}`));
      } else {
        try {
          const result = JSON.parse(dataString);
          resolve(result);
        } catch (error) {
          reject(new Error(`Failed to parse Python output: ${error.message}`));
        }
      }
    });
  });
}

// Calculate 24-hour pull point details
const next24hOps = lineview
  .filter(row => {
    const fls = safeNum(row.FULL_LOOP_SEQ);
    const op = safeNum(row.OPERATION);
    return fls > ppFullLoopSeq && fls <= beLsbFls && op !== 204;
  })
  .sort((a, b) => safeNum(a.FULL_LOOP_SEQ) - safeNum(b.FULL_LOOP_SEQ));

let cumCT = 0;
const ops24h = [];
for (const row of next24hOps) {
  const ct = safeNum(row.CT_GOAL, 0);
  cumCT += ct;
  if (cumCT <= config.catchup_ct_target) {
    ops24h.push(row);
  }
}

// Get 24hr range
const first24hOp = ops24h.length > 0 ? ops24h[0] : null;
const last24hOp = ops24h.length > 0 ? ops24h[ops24h.length - 1] : null;

// Get PS_OUTS and PPS_OUTS from finish operation
const finishOpRow = lineview.find(row => safeNum(row.OPERATION) === config.be_lsb_operation);
const psOuts = finishOpRow ? safeNum(finishOpRow.PS_OUTS, 0) : 0;
const ppsOuts = finishOpRow ? safeNum(finishOpRow.PPS_OUTS, 0) : 0;
const inventoryReduction24h = psOuts + ppsOuts;

// Calculate commit status (segment days vs calendar days)
const segmentDaysRemaining = Math.max(0, config.segment_day_end - safeNum(pullPoint.SEGMENT_DAY, 0));
const deadline = new Date(config.deadline);
const calendarDaysRemaining = Math.max(0, Math.ceil((deadline - now) / (1000 * 60 * 60 * 24)));
const commitAheadBehind = calendarDaysRemaining - segmentDaysRemaining;

// Calculate bump inventory
let bumpInventory = 0;
const opsWithW0 = opsWithPP.filter(op => op.PP_W === 0);
if (quarterRemaining > 0 && opsWithW0.length > 0) {
  const firstW0 = opsWithW0[0];
  const ppMod = firstW0.PP_INV % quarterRemaining;
  bumpInventory = quarterRemaining - ppMod;
}

// Get current week outs
const currentWeekOuts = finishOpRow ? safeNum(finishOpRow.CW_OUTS_PROD, 0) : 0;

// Calculate days and shifts left
const nextMonday = new Date(now);
nextMonday.setDate(now.getDate() + (7 - now.getDay()));
nextMonday.setHours(0, 0, 0, 0);
const hoursUntilMonday = Math.max(0, (nextMonday - now) / (1000 * 60 * 60));
const daysLeft = hoursUntilMonday / 24;
const shiftsLeft = Math.max(1, Math.floor(hoursUntilMonday / 12));
const outsRemainingThisWeek = Math.max(0, thisWeekRequired - currentWeekOuts);
const needPerDay = outsRemainingThisWeek / Math.max(1, daysLeft);
const needPerShift = needPerDay / 2;

const response = {
  timestamp: now.toISOString(),
  shift: {
    name: shiftInfo.shiftName,
    start: shiftInfo.shiftStart.toISOString(),
    hours_into: Math.round(shiftInfo.hoursIntoShift * 10) / 10,
    hours_remaining: Math.round(shiftInfo.hoursRemaining * 10) / 10,
    shipped: Math.round(shipmentData.current_shift_ships),
    target: Math.round(targetPerShift),
    pace_rate: Math.round(shiftPaceRate * 10) / 10,
    projected_end: Math.round(projectedShiftEnd),
    status: projectedShiftEnd >= targetPerShift ? 'ON PACE' : 'BEHIND PACE',
    ct_progress_needed: config.catchup_ct_target / 2  // Half of daily target
  },
  quarterly: {
    goal: config.quarter_goal,
    shipped: Math.round(shipmentData.quarter_ships),
    remaining: Math.round(quarterRemaining),
    percent_complete: Math.round((shipmentData.quarter_ships / config.quarter_goal) * 1000) / 10
  },
  weekly: {
    last_week_ships: Math.round(shipmentData.last_week_ships),
    weekly_goal: config.outs_goal,
    variance: Math.round(shipmentData.last_week_ships - config.outs_goal),
    this_week_required: Math.round(thisWeekRequired),
    this_week_shipped: Math.round(currentWeekOuts),
    remaining_this_week: Math.round(outsRemainingThisWeek),
    days_left: Math.round(daysLeft * 100) / 100,
    shifts_left: shiftsLeft,
    need_per_day: Math.round(needPerDay * 10) / 10,
    need_per_shift: Math.round(needPerShift * 10) / 10,
    shortfall: Math.round(totalShortfall)
  },
  daily: {
    last_24h_ships: Math.round(shipmentData.last_24h_ships),
    target: Math.round(targetPerShift * 2),
    variance: Math.round(shipmentData.last_24h_ships - (targetPerShift * 2)),
    status: shipmentData.last_24h_ships >= (targetPerShift * 2) ? 'HIT' : 'MISS'
  },
  pull_point: {
    current_sd: safeNum(pullPoint.SEGMENT_DAY, 0),
    current_ceid: pullPoint.CEID || 'N/A',
    current_operation: pullPoint.OPERATION || 'N/A',
    current_desc: pullPoint.OPER_SHORT_DESC || 'N/A',
    current_fls: ppFullLoopSeq,
    bump_inventory: Math.round(bumpInventory),
    segment_days_remaining: segmentDaysRemaining,
    calendar_days_remaining: calendarDaysRemaining,
    commit_ahead_behind: commitAheadBehind,
    commit_status: commitAheadBehind >= 0 ? 'AHEAD' : 'BEHIND'
  },
  pull_point_24h: {
    target_ct_hours: config.catchup_ct_target,
    operations_count: ops24h.length,
    start_sd: first24hOp ? safeNum(first24hOp.SEGMENT_DAY, 0) : 0,
    start_ceid: first24hOp ? first24hOp.CEID : 'N/A',
    end_sd: last24hOp ? safeNum(last24hOp.SEGMENT_DAY, 0) : 0,
    end_ceid: last24hOp ? last24hOp.CEID : 'N/A',
    end_desc: last24hOp ? last24hOp.OPER_SHORT_DESC : 'N/A',
    ps_outs: Math.round(psOuts),
    pps_outs: Math.round(ppsOuts),
    inventory_reduction: Math.round(inventoryReduction24h)
  },
  limiters,
  config
};


/**
 * API Endpoint: Get dashboard data
 */
/**
 * API Endpoint: Get dashboard data
 */
app.post('/api/dashboard', async (req, res) => {
  try {
    const config = req.body;
    const now = new Date();
    
    console.log('Reading LineView file...');
    const lineviewData = await readTSVFile(LINEVIEW_PATH, LOCAL_LINEVIEW_PATH);
    const lineview = parseTSV(lineviewData);
    
    console.log('Reading CEID file...');
    const ceidData = await readTSVFile(CEID_PATH, LOCAL_CEID_PATH);
    const ceid = parseTSV(ceidData);
    
    console.log(`Loaded ${lineview.length} lineview records and ${ceid.length} CEID records`);
    
    // Get shipment data from Python/PyUber (or use mock data)
    let shipmentData;
    try {
      shipmentData = await callPythonScript('db_queries.py', [JSON.stringify(config)]);
    } catch (error) {
      console.log('Database query failed, using mock data:', error.message);
      shipmentData = {
        current_shift_ships: 274,
        quarter_ships: 80025,
        last_week_ships: 7102,
        last_24h_ships: 816
      };
    }
    
    // Current shift info (matches Python get_current_shift_info)
    const shiftInfo = getCurrentShiftInfo();
    
    // Calculate shift targets (matches Python exactly)
    const targetPerShift = config.outs_goal / SHIFTS_PER_WEEK; // ~593 wafers/shift
    const shiftPaceRate = shiftInfo.hoursIntoShift > 0 
      ? shipmentData.current_shift_ships / shiftInfo.hoursIntoShift 
      : 0;
    const projectedShiftEnd = shipmentData.current_shift_ships + 
      (shiftPaceRate * shiftInfo.hoursRemaining);
    
    // Quarterly calculations
    const quarterRemaining = Math.max(0, config.quarter_goal - shipmentData.quarter_ships);
    
    // Get finish operation FLS
    const finishOp = lineview.find(row => safeNum(row.OPERATION) === config.be_lsb_operation);
    if (!finishOp) {
      throw new Error('Finish operation not found in lineview');
    }
    const beLsbFls = safeNum(finishOp.FULL_LOOP_SEQ);
    
    // Calculate quarterly pull point (matches Python)
    const pullPoint = calculateQuarterlyPullPoint(lineview, quarterRemaining, beLsbFls);
    const ppFullLoopSeq = safeNum(pullPoint.FULL_LOOP_SEQ);
    const ppSegmentDay = safeNum(pullPoint.SEGMENT_DAY, 0);
    
    // ============================================
    // CALCULATE BUMP INVENTORY (matches Python)
    // ============================================
    // Get all operations with PP_W values
    const relevantOps = lineview
      .filter(row => {
        const fls = safeNum(row.FULL_LOOP_SEQ);
        const op = safeNum(row.OPERATION);
        return fls !== null && fls <= beLsbFls && op !== 204;
      })
      .sort((a, b) => safeNum(a.FULL_LOOP_SEQ) - safeNum(b.FULL_LOOP_SEQ));
    
    // Calculate reverse cumulative inventory
    let cumulativeInv = 0;
    const opsWithPP = [];
    for (let i = relevantOps.length - 1; i >= 0; i--) {
      const row = relevantOps[i];
      cumulativeInv += safeNum(row.INV_PROD, 0);
      opsWithPP.unshift({
        ...row,
        PP_INV: cumulativeInv,
        PP_W: quarterRemaining > 0 ? Math.floor(cumulativeInv / quarterRemaining) : 0,
        PP_mod: quarterRemaining > 0 ? cumulativeInv % quarterRemaining : 0
      });
    }
    
    // Calculate bump inventory: quarter_remaining - first W=0 operation's PP_mod
    let bumpInventory = 0;
    if (quarterRemaining > 0) {
      const firstW0Op = opsWithPP.find(op => op.PP_W === 0);
      if (firstW0Op) {
        bumpInventory = quarterRemaining - firstW0Op.PP_mod;
      }
    }
    
    // ============================================
    // CALCULATE DAYS REMAINING (matches Python)
    // ============================================
    const deadline = new Date(config.deadline);
    const calendarDaysRemaining = Math.max(0, Math.ceil((deadline - now) / (1000 * 60 * 60 * 24)));
    const segmentDaysRemaining = Math.max(0, config.segment_day_end - ppSegmentDay);
    
    // Commit ahead/behind: calendar_days - segment_days
    // Positive = ahead of schedule, Negative = behind schedule
    const commitAheadBehind = calendarDaysRemaining - segmentDaysRemaining;
    const commitStatus = commitAheadBehind >= 0 ? 'AHEAD' : 'BEHIND';
    
    // ============================================
    // 24-HOUR PULL POINT CALCULATIONS
    // ============================================
    const next24hOps = lineview
      .filter(row => {
        const fls = safeNum(row.FULL_LOOP_SEQ);
        const op = safeNum(row.OPERATION);
        return fls > ppFullLoopSeq && fls <= beLsbFls && op !== 204;
      })
      .sort((a, b) => safeNum(a.FULL_LOOP_SEQ) - safeNum(b.FULL_LOOP_SEQ));

    let cumCT = 0;
    const ops24h = [];
    for (const row of next24hOps) {
      const ct = safeNum(row.CT_GOAL, 0);
      cumCT += ct;
      if (cumCT <= config.catchup_ct_target) {
        ops24h.push(row);
      }
    }

    // Get 24hr range
    const first24hOp = ops24h.length > 0 ? ops24h[0] : null;
    const last24hOp = ops24h.length > 0 ? ops24h[ops24h.length - 1] : null;

    // Get PS_OUTS and PPS_OUTS from finish operation
    const psOuts = safeNum(finishOp.PS_OUTS, 0);
    const ppsOuts = safeNum(finishOp.PPS_OUTS, 0);
    const inventoryReduction24h = psOuts + ppsOuts;
    
    // ============================================
    // WEEKLY CALCULATIONS (matches Python)
    // ============================================
    const weeksLeft = Math.max(1, Math.ceil((deadline - now) / (1000 * 60 * 60 * 24 * 7)));
    const totalShortfall = Math.max(0, config.outs_goal - shipmentData.last_week_ships);
    const catchupPerWeek = totalShortfall / weeksLeft;
    const thisWeekRequired = config.outs_goal + catchupPerWeek;
    
    // Get current week outs from CW_OUTS_PROD column
    const currentWeekOuts = safeNum(finishOp.CW_OUTS_PROD, 0);
    
    // Calculate days and shifts left (matches Python hours_until_next_monday)
    const currentDay = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
    const daysUntilMonday = currentDay === 0 ? 1 : (8 - currentDay);
    const nextMonday = new Date(now);
    nextMonday.setDate(now.getDate() + daysUntilMonday);
    nextMonday.setHours(0, 0, 0, 0);
    
    const hoursUntilMonday = Math.max(0, (nextMonday - now) / (1000 * 60 * 60));
    const daysLeft = hoursUntilMonday / 24;
    const shiftsLeft = Math.max(1, Math.floor(hoursUntilMonday / HOURS_PER_SHIFT));
    
    const outsRemainingThisWeek = Math.max(0, thisWeekRequired - currentWeekOuts);
    const needPerDay = outsRemainingThisWeek / Math.max(1, daysLeft);
    const needPerShift = needPerDay / 2; // Simply divide by 2 (matches Python)
    
    // Calculate limiters (matches Python)
    const limiters = calculateLimiters(lineview, ceid, ppFullLoopSeq, beLsbFls, config);
    
    // ============================================
    // BUILD RESPONSE
    // ============================================
    const response = {
      timestamp: now.toISOString(),
      shift: {
        name: shiftInfo.shiftName,
        start: shiftInfo.shiftStart.toISOString(),
        hours_into: Math.round(shiftInfo.hoursIntoShift * 10) / 10,
        hours_remaining: Math.round(shiftInfo.hoursRemaining * 10) / 10,
        shipped: Math.round(shipmentData.current_shift_ships),
        target: Math.round(targetPerShift),
        pace_rate: Math.round(shiftPaceRate * 10) / 10,
        projected_end: Math.round(projectedShiftEnd),
        status: projectedShiftEnd >= targetPerShift ? 'ON PACE' : 'BEHIND PACE',
        ct_progress_needed: config.catchup_ct_target / 2
      },
      quarterly: {
        goal: config.quarter_goal,
        shipped: Math.round(shipmentData.quarter_ships),
        remaining: Math.round(quarterRemaining),
        percent_complete: Math.round((shipmentData.quarter_ships / config.quarter_goal) * 1000) / 10
      },
      weekly: {
        last_week_ships: Math.round(shipmentData.last_week_ships),
        weekly_goal: config.outs_goal,
        variance: Math.round(shipmentData.last_week_ships - config.outs_goal),
        this_week_required: Math.round(thisWeekRequired),
        this_week_shipped: Math.round(currentWeekOuts),
        remaining_this_week: Math.round(outsRemainingThisWeek),
        days_left: Math.round(daysLeft * 100) / 100,
        shifts_left: shiftsLeft,
        need_per_day: Math.round(needPerDay * 10) / 10,
        need_per_shift: Math.round(needPerShift * 10) / 10,
        shortfall: Math.round(totalShortfall)
      },
      daily: {
        last_24h_ships: Math.round(shipmentData.last_24h_ships),
        target: Math.round(targetPerShift * 2),
        variance: Math.round(shipmentData.last_24h_ships - (targetPerShift * 2)),
        status: shipmentData.last_24h_ships >= (targetPerShift * 2) ? 'HIT' : 'MISS'
      },
      pull_point: {
        current_sd: ppSegmentDay,
        current_ceid: pullPoint.CEID || 'N/A',
        current_operation: pullPoint.OPERATION || 'N/A',
        current_desc: pullPoint.OPER_SHORT_DESC || 'N/A',
        current_fls: ppFullLoopSeq,
        bump_inventory: Math.round(bumpInventory),
        segment_days_remaining: segmentDaysRemaining,
        calendar_days_remaining: calendarDaysRemaining,
        commit_ahead_behind: commitAheadBehind,
        commit_status: commitStatus
      },
      pull_point_24h: {
        target_ct_hours: config.catchup_ct_target,
        operations_count: ops24h.length,
        start_sd: first24hOp ? safeNum(first24hOp.SEGMENT_DAY, 0) : ppSegmentDay,
        start_ceid: first24hOp ? (first24hOp.CEID || 'N/A') : 'N/A',
        end_sd: last24hOp ? safeNum(last24hOp.SEGMENT_DAY, 0) : ppSegmentDay,
        end_ceid: last24hOp ? (last24hOp.CEID || 'N/A') : 'N/A',
        end_desc: last24hOp ? (last24hOp.OPER_SHORT_DESC || 'N/A') : 'N/A',
        ps_outs: Math.round(psOuts),
        pps_outs: Math.round(ppsOuts),
        inventory_reduction: Math.round(inventoryReduction24h)
      },
      limiters,
      config
    };
    
    // Log key values for debugging
    console.log('\n=== Calculated Values ===');
    console.log(`Bump Inventory: ${bumpInventory}`);
    console.log(`Segment Days Remaining: ${segmentDaysRemaining} (End: ${config.segment_day_end}, Current: ${ppSegmentDay})`);
    console.log(`Calendar Days Remaining: ${calendarDaysRemaining}`);
    console.log(`Commit Status: ${commitAheadBehind >= 0 ? '+' : ''}${commitAheadBehind} days ${commitStatus}`);
    console.log('========================\n');
    
    res.json({ success: true, data: response });
    
  } catch (error) {
    console.error('Dashboard API error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message
    });
  }
});

/**
 * API Endpoint: Get historical shipment data
 */
/**
 * API Endpoint: Get dashboard data
 */
app.post('/api/dashboard', async (req, res) => {
  try {
    const config = req.body;
    const now = new Date();
    
    console.log('Reading LineView file...');
    const lineviewData = await readTSVFile(LINEVIEW_PATH, LOCAL_LINEVIEW_PATH);
    const lineview = parseTSV(lineviewData);
    
    console.log('Reading CEID file...');
    const ceidData = await readTSVFile(CEID_PATH, LOCAL_CEID_PATH);
    const ceid = parseTSV(ceidData);
    
    console.log(`Loaded ${lineview.length} lineview records and ${ceid.length} CEID records`);
    
    // Get shipment data from Python/PyUber (or use mock data)
    let shipmentData;
    try {
      shipmentData = await callPythonScript('db_queries.py', [JSON.stringify(config)]);
    } catch (error) {
      console.log('Database query failed, using mock data:', error.message);
      shipmentData = {
        current_shift_ships: 274,
        quarter_ships: 80025,
        last_week_ships: 7102,
        last_24h_ships: 816
      };
    }
    
    // Current shift info (matches Python get_current_shift_info)
    const shiftInfo = getCurrentShiftInfo();
    
    // Calculate shift targets (matches Python exactly)
    const targetPerShift = config.outs_goal / SHIFTS_PER_WEEK; // ~593 wafers/shift
    const shiftPaceRate = shiftInfo.hoursIntoShift > 0 
      ? shipmentData.current_shift_ships / shiftInfo.hoursIntoShift 
      : 0;
    const projectedShiftEnd = shipmentData.current_shift_ships + 
      (shiftPaceRate * shiftInfo.hoursRemaining);
    
    // Quarterly calculations
    const quarterRemaining = Math.max(0, config.quarter_goal - shipmentData.quarter_ships);
    
    // Get finish operation FLS
    const finishOp = lineview.find(row => safeNum(row.OPERATION) === config.be_lsb_operation);
    if (!finishOp) {
      throw new Error('Finish operation not found in lineview');
    }
    const beLsbFls = safeNum(finishOp.FULL_LOOP_SEQ);
    
    // Calculate quarterly pull point (matches Python)
    const pullPoint = calculateQuarterlyPullPoint(lineview, quarterRemaining, beLsbFls);
    const ppFullLoopSeq = safeNum(pullPoint.FULL_LOOP_SEQ);
    const ppSegmentDay = safeNum(pullPoint.SEGMENT_DAY, 0);
    
    // ============================================
    // CALCULATE BUMP INVENTORY (matches Python)
    // ============================================
    // Get all operations with PP_W values
    const relevantOps = lineview
      .filter(row => {
        const fls = safeNum(row.FULL_LOOP_SEQ);
        const op = safeNum(row.OPERATION);
        return fls !== null && fls <= beLsbFls && op !== 204;
      })
      .sort((a, b) => safeNum(a.FULL_LOOP_SEQ) - safeNum(b.FULL_LOOP_SEQ));
    
    // Calculate reverse cumulative inventory
    let cumulativeInv = 0;
    const opsWithPP = [];
    for (let i = relevantOps.length - 1; i >= 0; i--) {
      const row = relevantOps[i];
      cumulativeInv += safeNum(row.INV_PROD, 0);
      opsWithPP.unshift({
        ...row,
        PP_INV: cumulativeInv,
        PP_W: quarterRemaining > 0 ? Math.floor(cumulativeInv / quarterRemaining) : 0,
        PP_mod: quarterRemaining > 0 ? cumulativeInv % quarterRemaining : 0
      });
    }
    
    // Calculate bump inventory: quarter_remaining - first W=0 operation's PP_mod
    let bumpInventory = 0;
    if (quarterRemaining > 0) {
      const firstW0Op = opsWithPP.find(op => op.PP_W === 0);
      if (firstW0Op) {
        bumpInventory = quarterRemaining - firstW0Op.PP_mod;
      }
    }
    
    // ============================================
    // CALCULATE DAYS REMAINING (matches Python)
    // ============================================
    const deadline = new Date(config.deadline);
    const calendarDaysRemaining = Math.max(0, Math.ceil((deadline - now) / (1000 * 60 * 60 * 24)));
    const segmentDaysRemaining = Math.max(0, config.segment_day_end - ppSegmentDay);
    
    // Commit ahead/behind: calendar_days - segment_days
    // Positive = ahead of schedule, Negative = behind schedule
    const commitAheadBehind = calendarDaysRemaining - segmentDaysRemaining;
    const commitStatus = commitAheadBehind >= 0 ? 'AHEAD' : 'BEHIND';
    
    // ============================================
    // 24-HOUR PULL POINT CALCULATIONS
    // ============================================
    const next24hOps = lineview
      .filter(row => {
        const fls = safeNum(row.FULL_LOOP_SEQ);
        const op = safeNum(row.OPERATION);
        return fls > ppFullLoopSeq && fls <= beLsbFls && op !== 204;
      })
      .sort((a, b) => safeNum(a.FULL_LOOP_SEQ) - safeNum(b.FULL_LOOP_SEQ));

    let cumCT = 0;
    const ops24h = [];
    for (const row of next24hOps) {
      const ct = safeNum(row.CT_GOAL, 0);
      cumCT += ct;
      if (cumCT <= config.catchup_ct_target) {
        ops24h.push(row);
      }
    }

    // Get 24hr range
    const first24hOp = ops24h.length > 0 ? ops24h[0] : null;
    const last24hOp = ops24h.length > 0 ? ops24h[ops24h.length - 1] : null;

    // Get PS_OUTS and PPS_OUTS from finish operation
    const psOuts = safeNum(finishOp.PS_OUTS, 0);
    const ppsOuts = safeNum(finishOp.PPS_OUTS, 0);
    const inventoryReduction24h = psOuts + ppsOuts;
    
    // ============================================
    // WEEKLY CALCULATIONS (matches Python)
    // ============================================
    const weeksLeft = Math.max(1, Math.ceil((deadline - now) / (1000 * 60 * 60 * 24 * 7)));
    const totalShortfall = Math.max(0, config.outs_goal - shipmentData.last_week_ships);
    const catchupPerWeek = totalShortfall / weeksLeft;
    const thisWeekRequired = config.outs_goal + catchupPerWeek;
    
    // Get current week outs from CW_OUTS_PROD column
    const currentWeekOuts = safeNum(finishOp.CW_OUTS_PROD, 0);
    
    // Calculate days and shifts left (matches Python hours_until_next_monday)
    const currentDay = now.getDay(); // 0 = Sunday, 1 = Monday, etc.
    const daysUntilMonday = currentDay === 0 ? 1 : (8 - currentDay);
    const nextMonday = new Date(now);
    nextMonday.setDate(now.getDate() + daysUntilMonday);
    nextMonday.setHours(0, 0, 0, 0);
    
    const hoursUntilMonday = Math.max(0, (nextMonday - now) / (1000 * 60 * 60));
    const daysLeft = hoursUntilMonday / 24;
    const shiftsLeft = Math.max(1, Math.floor(hoursUntilMonday / HOURS_PER_SHIFT));
    
    const outsRemainingThisWeek = Math.max(0, thisWeekRequired - currentWeekOuts);
    const needPerDay = outsRemainingThisWeek / Math.max(1, daysLeft);
    const needPerShift = needPerDay / 2; // Simply divide by 2 (matches Python)
    
    // Calculate limiters (matches Python)
    const limiters = calculateLimiters(lineview, ceid, ppFullLoopSeq, beLsbFls, config);
    
    // ============================================
    // BUILD RESPONSE
    // ============================================
    const response = {
      timestamp: now.toISOString(),
      shift: {
        name: shiftInfo.shiftName,
        start: shiftInfo.shiftStart.toISOString(),
        hours_into: Math.round(shiftInfo.hoursIntoShift * 10) / 10,
        hours_remaining: Math.round(shiftInfo.hoursRemaining * 10) / 10,
        shipped: Math.round(shipmentData.current_shift_ships),
        target: Math.round(targetPerShift),
        pace_rate: Math.round(shiftPaceRate * 10) / 10,
        projected_end: Math.round(projectedShiftEnd),
        status: projectedShiftEnd >= targetPerShift ? 'ON PACE' : 'BEHIND PACE',
        ct_progress_needed: config.catchup_ct_target / 2
      },
      quarterly: {
        goal: config.quarter_goal,
        shipped: Math.round(shipmentData.quarter_ships),
        remaining: Math.round(quarterRemaining),
        percent_complete: Math.round((shipmentData.quarter_ships / config.quarter_goal) * 1000) / 10
      },
      weekly: {
        last_week_ships: Math.round(shipmentData.last_week_ships),
        weekly_goal: config.outs_goal,
        variance: Math.round(shipmentData.last_week_ships - config.outs_goal),
        this_week_required: Math.round(thisWeekRequired),
        this_week_shipped: Math.round(currentWeekOuts),
        remaining_this_week: Math.round(outsRemainingThisWeek),
        days_left: Math.round(daysLeft * 100) / 100,
        shifts_left: shiftsLeft,
        need_per_day: Math.round(needPerDay * 10) / 10,
        need_per_shift: Math.round(needPerShift * 10) / 10,
        shortfall: Math.round(totalShortfall)
      },
      daily: {
        last_24h_ships: Math.round(shipmentData.last_24h_ships),
        target: Math.round(targetPerShift * 2),
        variance: Math.round(shipmentData.last_24h_ships - (targetPerShift * 2)),
        status: shipmentData.last_24h_ships >= (targetPerShift * 2) ? 'HIT' : 'MISS'
      },
      pull_point: {
        current_sd: ppSegmentDay,
        current_ceid: pullPoint.CEID || 'N/A',
        current_operation: pullPoint.OPERATION || 'N/A',
        current_desc: pullPoint.OPER_SHORT_DESC || 'N/A',
        current_fls: ppFullLoopSeq,
        bump_inventory: Math.round(bumpInventory),
        segment_days_remaining: segmentDaysRemaining,
        calendar_days_remaining: calendarDaysRemaining,
        commit_ahead_behind: commitAheadBehind,
        commit_status: commitStatus
      },
      pull_point_24h: {
        target_ct_hours: config.catchup_ct_target,
        operations_count: ops24h.length,
        start_sd: first24hOp ? safeNum(first24hOp.SEGMENT_DAY, 0) : ppSegmentDay,
        start_ceid: first24hOp ? (first24hOp.CEID || 'N/A') : 'N/A',
        end_sd: last24hOp ? safeNum(last24hOp.SEGMENT_DAY, 0) : ppSegmentDay,
        end_ceid: last24hOp ? (last24hOp.CEID || 'N/A') : 'N/A',
        end_desc: last24hOp ? (last24hOp.OPER_SHORT_DESC || 'N/A') : 'N/A',
        ps_outs: Math.round(psOuts),
        pps_outs: Math.round(ppsOuts),
        inventory_reduction: Math.round(inventoryReduction24h)
      },
      limiters,
      config
    };
    
    // Log key values for debugging
    console.log('\n=== Calculated Values ===');
    console.log(`Bump Inventory: ${bumpInventory}`);
    console.log(`Segment Days Remaining: ${segmentDaysRemaining} (End: ${config.segment_day_end}, Current: ${ppSegmentDay})`);
    console.log(`Calendar Days Remaining: ${calendarDaysRemaining}`);
    console.log(`Commit Status: ${commitAheadBehind >= 0 ? '+' : ''}${commitAheadBehind} days ${commitStatus}`);
    console.log('========================\n');
    
    res.json({ success: true, data: response });
    
  } catch (error) {
    console.error('Dashboard API error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message
    });
  }
});

/**
 * Health check endpoint
 */
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'ok',
    timestamp: new Date().toISOString()
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`üöÄ Q4 Production Dashboard Server running at http://localhost:${PORT}`);
  console.log(`üìä API available at http://localhost:${PORT}/api/dashboard`);
  console.log(`üìà History API at http://localhost:${PORT}/api/history`);
  console.log(`\nüìÅ Data Paths:`);
  console.log(`   LineView: ${LINEVIEW_PATH}`);
  console.log(`   CEID: ${CEID_PATH}`);
});
