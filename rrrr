Looking at my script. i wnt to validate the math i am using, and the scripts functionality. 
for my limiter identification in the look ahead, use this instead
if avg_hao is 2 or more times more than CT_goal in our look ahead span, this will be a limiter
if INV_PROD is 2 or more times more than INV_GOAL this is a limiter
if PS_OUTS is 10% or more, less than DRUM_BEAT, this is a limiter

also use this fomular in my exisiting script. i think the functionality makes sense. but if not, change it and make it better .  
if not df_ceid.empty and "CEID" in df_ceid.columns and ceid is not None:
        ceid_row = df_ceid[df_ceid["CEID"] == str(ceid)]
        if not ceid_row.empty:
            roads = _get_val(ceid_row, "ROADS_CAPACITY")
            cs_pace = _get_val(ceid_row, "CS_PACE")
            wspw = _get_val(ceid_row, "CS_WSPW_PACE")
            wse = _get_val(ceid_row, "WSE_GOAL")

            if not math.isnan(wspw) and not math.isnan(wse):
                pace_gap = wse - wspw
                if pace_gap >= LIMITER_WSPW_GAP:
                    reasons.append(f"WSPW pace {pace_gap:.0f} below goal")

            if not math.isnan(roads) and not math.isnan(cs_pace) and roads >= OUTS_GOAL:
                if (cs_pace * 14) < OUTS_GOAL:
                    reasons.append(f"CS_PACE×14<{OUTS_GOAL} despite ROADS≥goal")


also, for my outputs, 
script should also tell what was shipped last week 
also, not that a pace of 8.3K is just pace/14, which is the number of shifts, that takes us to  (~593 wfr/shift)
so every shift, we watch our pull point and calculate where we should be at in the next 24 hours. and in the morning, if we get there we call it a HIT and if not, we call it a miss and show what the reason was. this script should calculate that too. so we are able to know where we need to be in the next 24 hours. 
basically there should be an out put like 

Pull point: 24hr = 34.5 CT hrs.
Last 24 hours: MISS ~ 4 hrs VIMhc 224 wfrs. short of DB.​
Next 24 hours: SD78 VIMhc M4TRM - SD80 DVDcr V3

note that we are trying to catch up so we are trying to complete a 35hour CT span in a 24 hour day span. 
below is my code. 


import math
import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from pathlib import Path

# =============================================================================
# CONFIGURATION
# =============================================================================
OUTS_GOAL = 8300
QUARTER_GOAL = 95100
DEADLINE = datetime(2025, 12, 7, 23, 59, 59)
QUARTER_START = datetime(2025, 9, 6, 18, 0)
COMMIT_WW = 202549
SSAFI_LSB_OPERATION = 9812
SEGMENT_DAY_END = 104

LOOKAHEAD_HOURS = 30
LAYER_COUNT_THRESHOLD = 0.30
LIMITER_HAO_VARIANCE = 3.5
LIMITER_WSPW_GAP = 1000

SHIFTS_PER_DAY = 2
HOURS_PER_SHIFT = 12
DAYS_PER_WEEK = 7

LINEVIEW_PATH = r"\\azshfs.intel.com\azanalysistop\AZAnalysis\1274_MAODATA\AZFSM_Production\COS_DB\Combined\LineView.TXT"
CEID_PATH = r"\\azshfs.intel.com\azanalysistop\AZAnalysis\1274_MAODATA\AZFSM_Production\COS_DB\Combined\CEID.TXT"
EXCLUDED_OPERATIONS = [204]

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================
def ceil_days(seconds: float) -> int:
    """Convert seconds to rounded-up calendar days."""
    return max(0, int(math.ceil(seconds / 86400.0)))


def round_up_days(n: float) -> int:
    """Round day difference while preserving ahead/behind sign."""
    if n >= 0:
        return int(math.ceil(n))
    return -int(math.ceil(abs(n)))


def hours_until_next_monday(now: datetime) -> float:
    """Get hours remaining until next Monday (for week remaining calc)."""
    nxt = (now + timedelta(days=(7 - now.weekday()))).replace(hour=0, minute=0, second=0, microsecond=0)
    return max(0.0, (nxt - now).total_seconds() / 3600.0)


def safe_num(value, default=np.nan):
    """Convert to float safely."""
    try:
        return float(value)
    except Exception:
        return default


def fmt_int(x):
    """Format integer output."""
    try:
        if pd.isna(x):
            return "—"
        return f"{int(round(x)):,}"
    except Exception:
        return str(x)


def fmt_float(x, d=1):
    """Format float with fixed decimals."""
    try:
        if pd.isna(x):
            return "—"
        return f"{x:,.{d}f}"
    except Exception:
        return str(x)


def load_tsv(path: str) -> pd.DataFrame:
    """Load TSV file safely."""
    p = Path(path)
    if not p.exists():
        raise FileNotFoundError(f"Missing data file: {path}")
    return pd.read_csv(p, sep="\t")


# =============================================================================
# DATABASE CONNECTOR
# =============================================================================
try:
    import PyUber
    _DB = None
    def get_db():
        global _DB
        if _DB is None:
            _DB = PyUber.connect("F32_PROD_XEUS")
        return _DB
except Exception:
    PyUber = None
    def get_db():
        raise RuntimeError("❌ PyUber unavailable — enable internal DB access.")


# =============================================================================
# LOAD DATA
# =============================================================================
now = datetime.now()
df_lineview = load_tsv(LINEVIEW_PATH)
df_ceid = pd.read_csv(CEID_PATH, sep="\t") if Path(CEID_PATH).exists() else pd.DataFrame()
db = get_db()

# Normalize data
df_lineview["FULL_LOOP_SEQ"] = pd.to_numeric(df_lineview.get("FULL_LOOP_SEQ", 0), errors="coerce").fillna(0)
df_lineview["INV_PROD"] = pd.to_numeric(df_lineview.get("INV_PROD", 0), errors="coerce").fillna(0)
if "SEGMENT_DAY" not in df_lineview.columns:
    df_lineview["SEGMENT_DAY"] = 0
if not df_ceid.empty and "CEID" in df_ceid.columns:
    df_ceid["CEID"] = df_ceid["CEID"].astype(str)

# =============================================================================
# QUARTERLY SHIPMENTS
# =============================================================================
quarter_sql = f"""
SELECT
    SUM(WAFER_QTY) AS TOTAL_WAFERS,
    COUNT(DISTINCT LOT) AS LOT_COUNT,
    MAX(OUT_DATE) AS LAST_SHIP_DATE,
    MIN(OUT_DATE) AS FIRST_SHIP_DATE
FROM F_LOT_RUN_CARD
WHERE
    OUT_DATE >= TO_DATE('{QUARTER_START:%m/%d/%Y %H:%M}', 'MM/DD/YYYY HH24:MI')
    AND OUT_DATE <= SYSDATE
    AND LOT_TYPE IN ('PROD','ENG')
    AND LOT LIKE 'L%' AND LOT NOT LIKE 'L9%'
    AND OPERATION = {SSAFI_LSB_OPERATION}
    AND WAFER_QTY > 0
"""
qdf = pd.read_sql(quarter_sql, db)
quarter_ships = safe_num(qdf["TOTAL_WAFERS"].iloc[0], 0)
lot_count = int(qdf["LOT_COUNT"].iloc[0] or 0)
first_ship = pd.to_datetime(qdf["FIRST_SHIP_DATE"].iloc[0])
last_ship = pd.to_datetime(qdf["LAST_SHIP_DATE"].iloc[0])
days_elapsed = max(1, (last_ship.normalize() - first_ship.normalize()).days + 1)
actual_daily_rate = quarter_ships / days_elapsed

# =============================================================================
# LAST WEEK SHIPMENTS
# =============================================================================
cur_monday = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0)
last_monday = cur_monday - timedelta(days=7)

last_week_sql = f"""
SELECT SUM(WAFER_QTY) AS TOTAL_WAFERS
FROM F_LOT_RUN_CARD
WHERE
    OUT_DATE >= TO_DATE('{last_monday:%m/%d/%Y %H:%M}', 'MM/DD/YYYY HH24:MI')
    AND OUT_DATE < TO_DATE('{cur_monday:%m/%d/%Y %H:%M}', 'MM/DD/YYYY HH24:MI')
    AND LOT_TYPE IN ('PROD','ENG')
    AND LOT LIKE 'L%' AND LOT NOT LIKE 'L9%'
    AND OPERATION = {SSAFI_LSB_OPERATION}
    AND WAFER_QTY > 0
"""
lwd = pd.read_sql(last_week_sql, db)
last_week_ships = safe_num(lwd["TOTAL_WAFERS"].iloc[0], 0)
last_ww = COMMIT_WW - 1

# =============================================================================
# QUARTERLY PP CALCULATION
# =============================================================================
ssafi_lsb_fls = float(df_lineview.loc[df_lineview["OPERATION"] == SSAFI_LSB_OPERATION, "FULL_LOOP_SEQ"].values[0])
quarter_remaining = max(0, QUARTER_GOAL - quarter_ships)

df_q = df_lineview.query(f"FULL_LOOP_SEQ <= {ssafi_lsb_fls} & OPERATION not in {EXCLUDED_OPERATIONS}").copy()
df_q["PP_INV"] = df_q["INV_PROD"].iloc[::-1].cumsum()[::-1]
df_q["PP_W"] = df_q["PP_INV"].apply(lambda x: x // quarter_remaining if quarter_remaining > 0 else np.nan)
df_q["PP_mod"] = df_q["PP_INV"].apply(lambda x: x % quarter_remaining if quarter_remaining > 0 else np.nan)

quarter_pp = df_q.query("PP_W == 1").tail(1)
if quarter_remaining > 0 and not df_q.query("PP_W == 0").empty:
    quarter_bump_inv = quarter_remaining - df_q.query("PP_W == 0").head(1)["PP_mod"].values[0]
else:
    quarter_bump_inv = 0

if quarter_pp.empty:
    print("❌ Insufficient WIP to reach quarterly goal.")
    quarter_pp = df_q.tail(1)

pp_segment_day = int(quarter_pp["SEGMENT_DAY"].values[0])
pp_full_loop_seq = float(quarter_pp["FULL_LOOP_SEQ"].values[0])

# =============================================================================
# TIME / SCHEDULE
# =============================================================================
seconds_remaining = max(0.0, (DEADLINE - now).total_seconds())
calendar_days_remaining = ceil_days(seconds_remaining)
segment_days_remaining = max(0, SEGMENT_DAY_END - pp_segment_day)
commit_ahead_behind_days = round_up_days(calendar_days_remaining - segment_days_remaining)
commit_status_icon = "✓ AHEAD" if commit_ahead_behind_days >= 0 else "❌ BEHIND"

# =============================================================================
# WEEKLY GOAL DISTRIBUTION
# =============================================================================
weeks_left = max(1, math.ceil((DEADLINE - now).days / 7))
total_shortfall = max(0, OUTS_GOAL - last_week_ships)
catchup_per_week = total_shortfall / weeks_left
this_week_required = OUTS_GOAL + catchup_per_week

if "CW_OUTS_PROD" in df_lineview.columns:
    current_week_outs = float(df_lineview.loc[df_lineview["OPERATION"] == SSAFI_LSB_OPERATION, "CW_OUTS_PROD"].values[0])
else:
    current_week_outs = 0

outs_remaining_this_week = max(0, this_week_required - current_week_outs)
hours_left = hours_until_next_monday(now)
days_left = max(1, int(hours_left // 24))
shifts_left = max(1, int(hours_left // HOURS_PER_SHIFT))
need_day = outs_remaining_this_week / days_left
need_shift = outs_remaining_this_week / shifts_left

# =============================================================================
# LIMITER ANALYSIS
# =============================================================================
def _get_val(df, col):
    try:
        if col in df.columns and not df.empty:
            return safe_num(df[col].iloc[0], np.nan)
        return np.nan
    except Exception:
        return np.nan

lookahead_ops = df_lineview.query(
    f"FULL_LOOP_SEQ > {pp_full_loop_seq} & FULL_LOOP_SEQ <= {ssafi_lsb_fls} & OPERATION not in {EXCLUDED_OPERATIONS}"
).copy()
if "LAYER_COUNT" in lookahead_ops.columns:
    lookahead_ops = lookahead_ops.query(f"LAYER_COUNT >= {LAYER_COUNT_THRESHOLD}")

lookahead_ops = lookahead_ops.sort_values("FULL_LOOP_SEQ").copy()
lookahead_ops["CT_GOAL"] = pd.to_numeric(lookahead_ops["CT_GOAL"], errors="coerce").fillna(0.0)
lookahead_ops["CUMULATIVE_CT"] = lookahead_ops["CT_GOAL"].cumsum()
lookahead_window = lookahead_ops.query(f"CUMULATIVE_CT <= {LOOKAHEAD_HOURS}").copy()

limiters = []
for _, row in lookahead_window.iterrows():
    reasons = []
    ceid = row.get("CEID", "N/A")
    ct_goal = safe_num(row.get("CT_GOAL", 0))
    avg_hao = safe_num(row.get("AVG_HAO", np.nan))
    max_hao = safe_num(row.get("MAX_HAO", np.nan))
    inv_prod = safe_num(row.get("INV_PROD", np.nan))
    inv_goal = safe_num(row.get("INV_GOAL", np.nan))

    if not math.isnan(avg_hao) and avg_hao > ct_goal:
        reasons.append(f"AVG_HAO>{ct_goal:.1f}")
    if not math.isnan(inv_prod) and not math.isnan(inv_goal) and inv_prod > inv_goal:
        reasons.append("INV>GOAL")

    if not df_ceid.empty and "CEID" in df_ceid.columns and ceid is not None:
        ceid_row = df_ceid[df_ceid["CEID"] == str(ceid)]
        if not ceid_row.empty:
            roads = _get_val(ceid_row, "ROADS_CAPACITY")
            cs_pace = _get_val(ceid_row, "CS_PACE")
            wspw = _get_val(ceid_row, "CS_WSPW_PACE")
            wse = _get_val(ceid_row, "WSE_GOAL")

            if not math.isnan(wspw) and not math.isnan(wse):
                pace_gap = wse - wspw
                if pace_gap >= LIMITER_WSPW_GAP:
                    reasons.append(f"WSPW pace {pace_gap:.0f} below goal")

            if not math.isnan(roads) and not math.isnan(cs_pace) and roads >= OUTS_GOAL:
                if (cs_pace * 14) < OUTS_GOAL:
                    reasons.append(f"CS_PACE×14<{OUTS_GOAL} despite ROADS≥goal")

    if reasons:
        limiters.append({
            "CEID": ceid,
            "OPERATION": row.get("OPERATION"),
            "OPER_SHORT_DESC": row.get("OPER_SHORT_DESC"),
            "SEGMENT_DAY": row.get("SEGMENT_DAY"),
            "CT_GOAL": ct_goal,
            "AVG_HAO": avg_hao,
            "INV_PROD": inv_prod,
            "INV_GOAL": inv_goal,
            "REASONS": " | ".join(reasons)
        })

# =============================================================================
# OUTPUT REPORT
# =============================================================================
print(f"""
{'='*110}
Q4 PRODUCTION CONTROL DASHBOARD | {now:%Y-%m-%d %H:%M:%S} | WW{COMMIT_WW}
{'='*110}

QUARTERLY PERFORMANCE:
  Goal:                                 {fmt_int(QUARTER_GOAL)} wafers
  Shipped to Date:                      {fmt_int(quarter_ships)} wafers
  Remaining:                            {fmt_int(quarter_remaining)} wafers

PULL POINT (Quarterly):
  Segment Day:                          SD{pp_segment_day}
  CEID:                                 {quarter_pp['CEID'].values[0] if 'CEID' in quarter_pp.columns else 'N/A'}
  Operation:                            {quarter_pp['OPERATION'].values[0] if 'OPERATION' in quarter_pp.columns else 'N/A'}
  Description:                          {quarter_pp['OPER_SHORT_DESC'].values[0] if 'OPER_SHORT_DESC' in quarter_pp.columns else 'N/A'}
  Bump Inventory from PP:               {fmt_int(quarter_bump_inv)} wafers
  Segment Days Remaining:               {fmt_int(segment_days_remaining)} days
  Calendar Days Remaining:              {fmt_int(calendar_days_remaining)} days
  Commit Status:                        {commit_ahead_behind_days:+} days {commit_status_icon}

WEEKLY TARGET (Auto-Adjusted):
  Shortfall (Last Week):                {fmt_int(total_shortfall)} wafers
  Weeks Remaining:                      {fmt_int(weeks_left)}
  Even Catch-up Allocation:             {fmt_int(catchup_per_week)} wafers/week
  This Week Required:                   {fmt_int(this_week_required)} wafers
  This Week Shipped:                    {fmt_int(current_week_outs)} wafers
  Remaining This Week:                  {fmt_int(outs_remaining_this_week)} wafers
  Days Left:                            {fmt_int(days_left)} | Shifts Left: {fmt_int(shifts_left)}
  Required per Day:                     {fmt_float(need_day)} wafers/day
  Required per Shift:                   {fmt_float(need_shift)} wafers/shift

LIMITER ANALYSIS ({LOOKAHEAD_HOURS}h Look-Ahead):
""")

if limiters:
    print(f"{'CEID':<12}{'Operation':<10}{'Description':<22}{'SD':<6}{'CT':<8}{'AVG':<8}{'INV':<8}Reasons")
    print("-" * 140)
    for lim in limiters:
        print(f"{str(lim['CEID'])[:12]:<12}{str(lim['OPERATION'])[:10]:<10}{str(lim['OPER_SHORT_DESC'])[:22]:<22}"
              f"{fmt_int(lim.get('SEGMENT_DAY',0)):<6}{fmt_float(lim.get('CT_GOAL',0)):<8}{fmt_float(lim.get('AVG_HAO',0)):<8}"
              f"{fmt_int(lim.get('INV_PROD',0)):<8}{lim['REASONS']}")
else:
    print("✓ No limiters identified in look-ahead window.")

print(f"\n{'='*110}\n")
