/**
 * This module handles data fetching for the Tool Analytics Dashboard.
 * It includes functions to fetch real data from an API and fallback to mock data if needed.
 */
import type { ToolData } from "@/types/tool"
import { generateMockData } from "./mockData"
import sql from "mssql";

// Utility function for delay
/**
 * Utility function to create a delay
 * @param ms - The number of milliseconds to delay
 * @returns A promise that resolves after the specified delay
 */


const config = {
  user: "COS_DB_rw",
  password: "mOkUgTq942jQ16r",
  server: "sql3561-fm1-in.amr.corp.intel.com,3181", // or is it supposed to  'localhost', '192.168.1.100'
  database: "COS_DB",
  options: {
    encrypt: true, // Use encryption if required
    trustServerCertificate: true, // Set to true if using self-signed certificates
  },

};
let poolPromise;

if (!global.poolPromise) {
  global.poolPromise = sql.connect(config)
    .then(pool => {
      console.log("Connected to SQL Server");
      return pool;
    })
    .catch(err => {
      console.error("Database connection failed", err);
      throw err;
    });
}

export default async function getDbPool() {
  return await global.poolPromise;
}
const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))

/**
 * Attempts to fetch real data from the API with retry mechanism
 * @param retries - The number of retry attempts (default: 3)
 * @returns A promise that resolves to an array of ToolData
 * @throws An error if all retry attempts fail
 */
async function fetchRealData(retries = 3): Promise<ToolData[]> {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const response = await fetch("https://fm1.iglb.intel.com/reports/report/COS_DB_SSRS/Reports/ABA_History", {
        headers: {
          "Content-Type": "application/json",
          // Add any necessary authentication headers here
        },
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}, statusText: ${response.statusText}`)
      }

      const data = await response.json()

      if (!Array.isArray(data) || !data.every(isValidToolData)) {
        throw new Error("Invalid data format received from the server")
      }

      return data as ToolData[]
    } catch (error) {
      console.error(`Attempt ${attempt} failed:`, error instanceof Error ? error.message : String(error))
      if (attempt === retries) {
        throw error
      }
      // Wait before retrying (exponential backoff)
      await delay(Math.pow(2, attempt) * 1000)
    }
  }
  throw new Error("All retry attempts failed")
}

/**
 * Validates if the provided item conforms to the ToolData structure
 * @param item - The item to validate
 * @returns A boolean indicating whether the item is valid ToolData
 */
function isValidToolData(item: any): item is ToolData {
  return (
    typeof item === "object" &&
    item !== null &&
    typeof item.name === "string" &&
    typeof item.limitations === "object" &&
    Object.values(item.limitations).every((val) => typeof val === "number")
  )
}

/**
 * Main function to fetch tool data. Attempts to fetch real data and falls back to mock data if unsuccessful.
 * @returns An object containing the fetched data, a flag indicating if it's mock data, and any error message
 */
export async function fetchToolData(): Promise<{ data: ToolData[]; isMockData: boolean; error: string | null }> {
  try {
    const realData = await fetchRealData()
    return { data: realData, isMockData: false, error: null }
  } catch (error) {
    console.warn("Failed to fetch real data, falling back to mock data")
    let errorMessage = "Unknown error occurred"
    if (error instanceof Error) {
      console.error("Error details:", error.message)
      errorMessage = `Failed to fetch real data: ${error.message}`
    } else {
      console.error("Unknown error occurred:", error)
    }
    return { data: generateMockData(), isMockData: true, error: errorMessage }
  }
}

