Heres what i think so tell me if i am wrong or not so we can agree on the fixes needed for this script. 
Looking at this updated script, I can see you've fixed several of the major issues I identified, but there are still some calculation problems:
1. Intel Work Week Calculation Issue
The calculate_weeks_between_ww function has a fundamental flaw:
PYTHON
def calculate_weeks_between_ww(start_ww: int, end_ww: int) -> int:
    # ...
    weeks_in_start_year = 52  # Approximation - THIS IS WRONG
    
    weeks_remaining_start_year = weeks_in_start_year - start_week
    years_between = end_year - start_year - 1
    weeks_in_end_year = end_week
    
    total_weeks = weeks_remaining_start_year + (years_between * 52) + weeks_in_end_year
Problems:
Intel work weeks don't always have exactly 52 weeks per year (can be 52 or 53)
The calculation assumes all years have 52 weeks
This will cause incorrect forecasting when crossing year boundaries
Fix:
PYTHON
def calculate_weeks_between_ww(start_ww: int, end_ww: int) -> int:
    """Calculate weeks between Intel work weeks by converting to dates"""
    # Convert work weeks to actual dates and calculate difference
    start_date = ww_to_date(start_ww)  # You'd need to implement this
    end_date = ww_to_date(end_ww)
    return (end_date - start_date).days // 7
2. Dynamic CT Target Boundary Logic
PYTHON
# STILL PROBLEMATIC - Hard caps may not reflect reality
daily_ct_target = max(24.0, min(daily_ct_target, 50.0))
If you truly need 60+ hours/day to catch up, capping at 50 hours gives false confidence. Consider:
PYTHON
# More realistic bounds
daily_ct_target = max(18.0, daily_ct_target)  # Only prevent impossibly low values
if daily_ct_target > 48.0:
    print(f"[WARNING] Extremely high CT target required: {daily_ct_target:.1f}h/day")
3. Segment Inventory Calculation Still Unclear
PYTHON
# This adds bump to ALL non-zero segments
segment_pp_remaining = base + (base != 0) * bump_inv
The comment says "cumulative" but the logic suggests you want to add bump inventory to each segment. If it's truly cumulative, you should only add to the final total:
PYTHON
# If truly cumulative (total WIP that must flow through each stage)
segment_pp_remaining = base.copy()
if segment_pp_remaining.iloc[-1] > 0:  # Only if BE has inventory
    segment_pp_remaining += bump_inv  # Add to all stages
4. X-Site Inventory Display Bug
PYTHON
# Display adjusted inventory
print(f"Adjusted total INV_PROD: {df_lineview['INV_PROD'].sum()}")  # WRONG - still shows original
Should be:
PYTHON
print(f"Adjusted total INV_PROD: {df_q['INV_PROD'].sum()}")  # Show the modified data
5. Progress Calculation Potential Issue
PYTHON
# FIXED: Calculate expected segment day based on linear time progression
if total_calendar_days > 0:
    time_progress_pct = calendar_days_elapsed / total_calendar_days
    expected_segment_day = time_progress_pct * segment_day_end
This assumes linear progress, but manufacturing rarely follows linear patterns. You might want to consider:
Ramp-up periods at quarter start
Different progress rates for different segments
Historical progress curves
6. Cumulative CT Calculation Order (Still Present)
In the 24-hour tracking:
PYTHON
path_forward["CT_EFFECTIVE"] = path_forward["CT_GOAL"] * path_forward["LAYER_COUNT"]
path_forward.loc[path_forward["LAYER_COUNT"] <= 0.02, "CT_EFFECTIVE"] = 0.0  # Should be BEFORE cumsum
path_forward["CUMULATIVE_CT"] = path_forward["CT_EFFECTIVE"].cumsum()
This is actually correct now - you fixed this one!
7. Potential Division by Zero
PYTHON
# In segment inventory display
FE: {(data['segment_fe'] / data['segment_be'] * 100) if data['segment_be'] > 0 else 0:.1f}%
Good defensive programming, but if segment_be is 0, the percentages become meaningless. Consider showing "N/A" instead.
Summary
The most critical remaining issues are:
Intel work week calculation - will cause wrong forecasts across year boundaries
X-site inventory display bug - shows wrong totals in logs
Segment inventory logic - unclear if the bump should be added to all segments or just final
The mathematical fixes you implemented for the blame analysis and progress calculation look correct now!
