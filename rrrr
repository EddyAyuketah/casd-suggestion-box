def calc_segment_pp_remaining(df_lineview: pd.DataFrame,
                              pp_operation: int,
                              bump_inv: float) -> pd.Series:
    """
    Calculate remaining inventory per segment after a given operation.
 
    Segments:
        - FE:    FULL_LOOP_SEQ < OPERATION 175084
        - SSAFI: between OPERATION 175084 and 185006
        - BE:    FULL_LOOP_SEQ >= OPERATION 185006
    """
 
    # Cache lookups to avoid repeated boolean indexing
    fe_cut = df_lineview.loc[df_lineview["OPERATION"] == 175084, "FULL_LOOP_SEQ"].iloc[0]
    ssafi_cut = df_lineview.loc[df_lineview["OPERATION"] == 185006, "FULL_LOOP_SEQ"].iloc[0]
    pp_fls = df_lineview.loc[df_lineview["OPERATION"] == pp_operation, "FULL_LOOP_SEQ"].iloc[0]
 
    # Assign segment tags
    df_lineview = df_lineview.copy()
    df_lineview["SEGMENT_TAG"] = pd.cut(
        df_lineview["FULL_LOOP_SEQ"],
        bins=[0, fe_cut, ssafi_cut, np.inf],
        labels=["FE", "SSAFI", "BE"],
        right=True,          
        include_lowest=True  
    )
 
    # Aggregate and ensure fixed segment order with 0 for missing segments
    base = (
        df_lineview.loc[df_lineview["FULL_LOOP_SEQ"] > pp_fls]
        .groupby("SEGMENT_TAG", observed=True)["INV_PROD"]
        .sum()
        .reindex(["FE", "SSAFI", "BE"], fill_value=0)
        .cumsum()
    )
 
    # Add bump only to non-zero (non-empty) segments
    segment_pp_remaining = base + (base != 0) * bump_inv
 
    return segment_pp_remaining
